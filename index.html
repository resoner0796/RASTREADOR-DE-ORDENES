<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Analizador de Órdenes — Rastreo de Seriales</title>

<!-- Estilos renovados (oscuro, profesional) -->
<style>
  :root{
    --bg:#071026; --panel:#0b1724; --muted:#9fb0c8; --accent:#3b82f6;
    --success:#10b981; --danger:#ef4444; --warn:#f59e0b; --glass: rgba(255,255,255,0.03);
    font-family: Inter, Roboto, "Segoe UI", system-ui, Arial, sans-serif;
    color-scheme: dark;
  }

  html,body{height:100%; margin:0; background:linear-gradient(180deg,var(--bg) 0%, #041525 100%); color:#e6eef8;}
  .container{max-width:1150px; margin:28px auto; padding:20px;}
  header{display:flex; gap:16px; align-items:center; margin-bottom:18px;}
  header h1{font-size:20px; margin:0; letter-spacing:0.2px}
  header p {margin:0; color:var(--muted); font-size:13px}

  .panel{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); padding:14px; border-radius:12px; box-shadow: 0 8px 30px rgba(2,6,23,0.6);}
  .flex{display:flex; gap:12px; align-items:center;}
  .col{flex:1;}
  label{display:block; font-size:13px; color:var(--muted); margin-bottom:8px;}
  input[type=file]{color:var(--muted);}
  textarea{width:100%; min-height:120px; background:transparent; border:1px dashed var(--glass); color:inherit; padding:10px; border-radius:8px; resize:vertical;}
  button{background:var(--accent); border:none; color:white; padding:10px 14px; border-radius:10px; cursor:pointer; font-weight:600;}
  button.ghost{background:transparent; border:1px solid rgba(255,255,255,0.06);}
  button.small{padding:6px 10px; font-size:13px; border-radius:8px;}
  .cards{display:grid; grid-template-columns: repeat(auto-fit,minmax(170px,1fr)); gap:12px; margin-top:12px;}
  .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); padding:14px; border-radius:10px; display:flex; flex-direction:column; gap:6px;}
  .card .title{font-size:12px; color:var(--muted);}
  .card .value{font-size:20px; font-weight:700;}
  .card .note{font-size:12px; color:var(--muted);}

  .filters{display:flex; gap:8px; flex-wrap:wrap; margin-top:12px; align-items:center;}
  select, .small-input{background:rgba(255,255,255,0.02); border:1px solid rgba(255,255,255,0.04); color:inherit; padding:8px 10px; border-radius:8px;}
  .hint{font-size:12px; color:var(--muted); margin-top:8px;}

  .table-wrap{max-height:410px; overflow:auto; border-radius:10px; margin-top:12px; border:1px solid rgba(255,255,255,0.03);}
  table{width:100%; border-collapse:collapse; font-size:13px; min-width:900px;}
  thead th{position:sticky; top:0; background:linear-gradient(180deg,#071b30,#062235); color:var(--muted); font-weight:700; padding:10px; text-align:left; border-bottom:1px solid rgba(255,255,255,0.03);}
  tbody td{padding:10px; border-bottom:1px solid rgba(255,255,255,0.02);}
  tbody tr:nth-child(even){background: rgba(255,255,255,0.01);}
  tbody tr:hover{background: rgba(59,130,246,0.06);}

  /* Row highlights */
  .row-scrap{ background: linear-gradient(90deg, rgba(239,68,68,0.06), rgba(239,68,68,0.03)); border-left:4px solid rgba(239,68,68,0.9); }
  .row-no-mov{ background: linear-gradient(90deg, rgba(245,158,11,0.06), rgba(245,158,11,0.03)); border-left:4px solid rgba(245,158,11,0.85); }

  .tag{display:inline-block; padding:6px 8px; border-radius:999px; font-weight:700; font-size:12px;}
  .tag.success{background: rgba(16,185,129,0.09); color:var(--success);}
  .tag.danger{background: rgba(239,68,68,0.09); color:var(--danger);}
  .tag.warn{background: rgba(245,158,11,0.09); color:var(--warn);}

  .footer{margin-top:12px; color:var(--muted); font-size:13px;}
  @media (max-width:760px){ header{flex-direction:column; align-items:flex-start;} .table-wrap{overflow:auto;} }
</style>
</head>
<body>
  <div class="container">
    <header>
      <div>
        <h1>Analizador de Órdenes — Rastreo de Seriales</h1>
        <p>Sube tu Excel o pega la tabla (desde Excel Ctrl+C → Ctrl+V). Detecta scrap, sin movimiento y facilita reimpresiones.</p>
      </div>
      <div style="margin-left:auto" class="small">
        <div class="hint">Zona horaria: <strong>America/Monterrey</strong></div>
      </div>
    </header>

    <div class="panel" role="region" aria-label="Herramienta principal">
      <div class="flex" style="gap:20px; align-items:flex-start;">
        <div style="min-width:260px">
          <label>Subir archivo (.xlsx / .xls / .csv)</label>
          <input id="file" type="file" accept=".xlsx,.xls,.csv" />
          <div class="hint">También puedes pegar la tabla en el recuadro de la derecha.</div>
        </div>

        <div style="flex:1">
          <label>Pegar datos (desde Excel: selecciona -> Ctrl + C -> aquí Ctrl + V)</label>
          <textarea id="pasteArea" placeholder="Pegado: columnas como Serial, Creation Date, Created By, NotPacked, IsScrap, Área, Línea, Station, Status, Date registered"></textarea>
          <div style="display:flex; gap:8px; margin-top:10px;">
            <button id="analyze" class="small">Analizar datos</button>
            <button id="clear" class="small ghost">Limpiar</button>
            <button id="sample" class="small ghost">Cargar ejemplo</button>
            <button id="help" class="small ghost" title="Cómo pegar correctamente">¿Cómo pegar?</button>
          </div>
        </div>
      </div>

      <div class="filters" style="margin-top:12px;">
        <label class="small">Filtro rápido:</label>
        <select id="areaFilter"><option value="">Todas las Áreas</option></select>
        <select id="lineFilter"><option value="">Todas las Líneas</option></select>
        <select id="stationFilter"><option value="">Todas las Stations</option></select>
        <select id="statusFilter"><option value="">Todos los Status</option></select>
        <button id="exportCSV" class="small ghost" title="Copiar tabla visible">Copiar tabla</button>
        <div style="margin-left:auto; display:flex; gap:8px; align-items:center;">
          <div class="small hint">Leyenda:</div>
          <div class="tag danger">SCRAP</div>
          <div class="tag warn">Sin movimiento (últimos 2 días)</div>
        </div>
      </div>

      <div id="summary" class="cards" aria-live="polite" style="margin-top:12px"></div>

      <div class="results">
        <div class="table-wrap panel" id="tableWrap" style="margin-top:12px; padding:0;">
          <table id="resultsTable" role="table" aria-label="Resultados">
            <thead>
              <tr>
                <th>Serial</th><th>Área</th><th>Línea</th><th>Station</th><th>Status</th><th>NotPacked</th><th>IsScrap</th><th>Date registered</th><th>Comentario</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>

      <div class="footer">
        Consejo: el parser es flexible con encabezados (ignora mayúsculas/minúsculas). Si tus fechas traen horas, igual las normaliza en la zona <strong>America/Monterrey</strong>.
      </div>
    </div>
  </div>

  <!-- SheetJS para leer Excel en el navegador -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

  <script>
  (function(){
    const TZ = 'America/Monterrey';

    // canonical header variants (case-insensitive)
    const canonical = {
      serial: ['serial','id','serial number','serialno'],
      creationDate: ['creation date','created date','date created','creationdate'],
      createdBy: ['created by','creator'],
      notPacked: ['notpacked','not packed','not_packed'],
      isScrap: ['isscrap','is scrap','scrap','is_scrap','isscrapped'],
      area: ['área','area','department'],
      line: ['línea','line','linea'],
      station: ['station','estacion','estación'],
      status: ['status','estado'],
      dateRegistered: ['date registered','date_registered','registered date','fecha registrada','date']
    };

    // UI refs
    const fileInput = document.getElementById('file');
    const pasteArea = document.getElementById('pasteArea');
    const analyzeBtn = document.getElementById('analyze');
    const clearBtn = document.getElementById('clear');
    const sampleBtn = document.getElementById('sample');
    const helpBtn = document.getElementById('help');
    const summaryEl = document.getElementById('summary');
    const resultsTbody = document.querySelector('#resultsTable tbody');
    const areaFilter = document.getElementById('areaFilter');
    const lineFilter = document.getElementById('lineFilter');
    const stationFilter = document.getElementById('stationFilter');
    const statusFilter = document.getElementById('statusFilter');
    const exportCSV = document.getElementById('exportCSV');

    let parsedRows = []; // canonical objects

    // --- Helpers ---
    function findColMap(headers){
      const map = {};
      const lcHeaders = headers.map(h => (h||'').toString().trim().toLowerCase());
      for (let i=0;i<lcHeaders.length;i++){
        const h = lcHeaders[i];
        for (const [key, variants] of Object.entries(canonical)){
          for (const v of variants){
            const vs = v.toLowerCase();
            if (h === vs || h.includes(vs) || vs.includes(h) && h.length>0) {
              map[key] = i;
            }
          }
        }
      }
      return map;
    }

    function truthy(val){
      if (val === undefined || val === null) return false;
      const s = String(val).trim().toLowerCase();
      return ['true','1','si','sí','yes','y','x','t'].includes(s);
    }

    // Return yyyy-mm-dd in TZ for a given Date or date-like input
    function toTZDateString(dateInput){
      if (!dateInput) return null;
      const d = (dateInput instanceof Date) ? dateInput : new Date(dateInput);
      if (isNaN(d)) return null;
      try {
        const df = new Intl.DateTimeFormat('en', { timeZone: TZ, year:'numeric', month:'2-digit', day:'2-digit' });
        const parts = df.formatToParts(d);
        const y = parts.find(p=>p.type==='year').value;
        const m = parts.find(p=>p.type==='month').value;
        const day = parts.find(p=>p.type==='day').value;
        return `${y}-${m}-${day}`;
      } catch(e){
        // fallback
        const iso = d.toISOString();
        return iso.split('T')[0];
      }
    }

    // get today, yesterday, anteayer strings in TZ
    function getRelativeDates(){
      const tzNowStr = new Date().toLocaleString('en-US', { timeZone: TZ });
      const tzNow = new Date(tzNowStr);
      const day0 = new Date(tzNow.getFullYear(), tzNow.getMonth(), tzNow.getDate());
      const day1 = new Date(day0); day1.setDate(day0.getDate()-1);
      const day2 = new Date(day0); day2.setDate(day0.getDate()-2);
      const fmt = d => {
        const y = d.getFullYear(), m = String(d.getMonth()+1).padStart(2,'0'), dd = String(d.getDate()).padStart(2,'0');
        return `${y}-${m}-${dd}`;
      };
      return { today: fmt(day0), yesterday: fmt(day1), anteayer: fmt(day2) };
    }

    // Parse pasted text (CSV/TSV) and return {headers, rows}
    function parseClipboardText(text){
      // Try to let SheetJS parse CSV/TSV robustly
      try {
        const wb = XLSX.read(text, { type:'string', raw:false, codepage:65001 });
        const sheet = wb.Sheets[wb.SheetNames[0]];
        const arr = XLSX.utils.sheet_to_json(sheet, { raw:false, defval:'' });
        return { headers: Object.keys(arr[0]||{}), rows: arr };
      } catch(e){
        // fallback simple parse
        const lines = text.trim().split(/\r\n|\n/).filter(l=>l.trim());
        if (lines.length<1) return { headers:[], rows:[] };
        const delim = lines[0].includes('\t') ? '\t' : (lines[0].includes(',') ? ',' : null);
        const headers = delim ? lines.shift().split(delim).map(h=>h.trim()) : [];
        const rows = lines.map(l => {
          const cols = delim ? l.split(delim) : [l];
          const obj = {};
          headers.forEach((h,i)=> obj[h]=cols[i] ? cols[i].trim() : '');
          return obj;
        });
        return { headers, rows };
      }
    }

    // Main processing of clipboard/csv text
    function processClipboard(text){
      const parsed = parseClipboardText(text);
      if (!parsed || !parsed.headers.length){
        alert('No se detectaron columnas. Asegúrate de pegar la tabla completa (incluyendo encabezados).');
        return;
      }
      const headers = parsed.headers;
      const map = findColMap(headers);

      parsedRows = parsed.rows.map(raw => {
        const obj = {};
        function getByMap(key){
          if (map[key] !== undefined) {
            const headerName = headers[map[key]];
            return raw[headerName] !== undefined ? raw[headerName] : raw[Object.keys(raw)[map[key]]];
          }
          // try direct keys case-insensitive
          for (const k of Object.keys(raw)){
            if (k.trim().toLowerCase() === key.toLowerCase()) return raw[k];
          }
          return raw[key] || '';
        }

        obj.serial = (getByMap('serial') || '').toString().trim();
        obj.area = (getByMap('area') || '').toString().trim();
        obj.line = (getByMap('line') || '').toString().trim();
        obj.station = (getByMap('station') || '').toString().trim();
        obj.status = (getByMap('status') || '').toString().trim();
        obj.notPacked = getByMap('notPacked') || getByMap('NotPacked') || '';
        obj.isScrap = getByMap('isScrap') || getByMap('IsScrap') || '';
        obj.dateRegisteredRaw = getByMap('dateRegistered') || getByMap('Date registered') || getByMap('Date Registered') || '';

        // Try parse date robustly: excel numeric serial or string
        let parsedDate = null;
        if (obj.dateRegisteredRaw){
          const maybeNum = Number(String(obj.dateRegisteredRaw).trim());
          if (!isNaN(maybeNum) && String(obj.dateRegisteredRaw).trim().length < 8 && String(obj.dateRegisteredRaw).indexOf('-')===-1 && String(obj.dateRegisteredRaw).indexOf('/')===-1){
            // probable Excel serial (small length)
            const excelStart = new Date(Date.UTC(1899,11,30));
            parsedDate = new Date(excelStart.getTime() + maybeNum * 24*60*60*1000);
          } else {
            // try Date parse, then try replace / with - if needed
            let tryDate = new Date(obj.dateRegisteredRaw);
            if (!isNaN(tryDate)) parsedDate = tryDate;
            else {
              const t2 = new Date(String(obj.dateRegisteredRaw).replace(/\./g,'-').replace(/\//g,'-'));
              if (!isNaN(t2)) parsedDate = t2;
            }
          }
        }
        obj.dateRegistered = parsedDate;
        return obj;
      });

      runAnalysis();
    }

    // File upload reading (xlsx/csv)
    fileInput.addEventListener('change', async (e) => {
      const f = e.target.files && e.target.files[0];
      if (!f) return;
      try {
        const data = await f.arrayBuffer();
        const wb = XLSX.read(data, { type: 'array' });
        const first = wb.Sheets[wb.SheetNames[0]];
        const csv = XLSX.utils.sheet_to_csv(first);
        // Put CSV in textarea for transparency and process
        pasteArea.value = csv;
        processClipboard(csv);
      } catch (err) {
        alert('Error leyendo archivo: ' + (err.message || err));
      }
    });

    // Run analysis and update UI
    function runAnalysis(){
      const rel = getRelativeDates();
      const total = parsedRows.length;
      let scrapCount = 0, notPackedCount = 0;
      const noDate = [];
      const noMovYesterday = [], noMovAnteayer = [];
      const areas = new Set(), lines = new Set(), stations = new Set(), statuses = new Set();

      parsedRows.forEach(r => {
        if (truthy(r.isScrap)) scrapCount++;
        if (truthy(r.notPacked)) notPackedCount++;

        const ds = toTZDateString(r.dateRegistered);
        if (!ds) noDate.push(r);

        // If last registered date is NOT yesterday -> counts as "no mov yesterday"
        if (!ds || ds !== rel.yesterday) noMovYesterday.push(r);
        if (!ds || ds !== rel.anteayer) noMovAnteayer.push(r);

        if (r.area) areas.add(r.area);
        if (r.line) lines.add(r.line);
        if (r.station) stations.add(r.station);
        if (r.status) statuses.add(r.status);
      });

      // render summary cards
      summaryEl.innerHTML = '';
      function c(title, big, hint=''){ const div=document.createElement('div'); div.className='card'; div.innerHTML = `<div class="title">${title}</div><div class="value">${big}</div>${hint?`<div class="note">${hint}</div>`:''}`; summaryEl.appendChild(div); }
      c('Total seriales', total);
      c('Seriales en scrap', scrapCount, `<span class="tag danger">${scrapCount}</span>`);
      c('No empaquetados (NotPacked)', notPackedCount, `<span class="tag">${notPackedCount}</span>`);
      c('Sin fecha de registro', noDate.length, `<span class="small">Revisar por posible falta de movimiento</span>`);
      c(`No mov. ayer (${rel.yesterday})`, noMovYesterday.length, `<span class="small">No registraron movimiento ayer</span>`);
      c(`No mov. anteayer (${rel.anteayer})`, noMovAnteayer.length, `<span class="small">No registraron movimiento anteayer</span>`);

      populateFilter(areaFilter, Array.from(areas).sort());
      populateFilter(lineFilter, Array.from(lines).sort());
      populateFilter(stationFilter, Array.from(stations).sort());
      populateFilter(statusFilter, Array.from(statuses).sort());

      renderTable(parsedRows, rel);
    }

    function populateFilter(selectEl, values){
      const current = selectEl.value || '';
      selectEl.innerHTML = '<option value="">Todos</option>';
      values.forEach(v => {
        const opt = document.createElement('option'); opt.value = v; opt.textContent = v; selectEl.appendChild(opt);
      });
      if (current) selectEl.value = current;
    }

    // Render table; coloring rules:
    // - Scrap rows (IsScrap truthy) -> red class (priority)
    // - Else if last registered date NOT in [today,yesterday,anteayer] OR missing -> yellow (sin movimiento reciente)
    function renderTable(rows, rel){
      resultsTbody.innerHTML = '';
      const af = areaFilter.value, lf = lineFilter.value, sf = stationFilter.value, stf = statusFilter.value;

      const visible = rows.filter(r => {
        if (af && r.area !== af) return false;
        if (lf && r.line !== lf) return false;
        if (sf && r.station !== sf) return false;
        if (stf && r.status !== stf) return false;
        return true;
      });

      visible.forEach(r => {
        const tr = document.createElement('tr');
        const ds = toTZDateString(r.dateRegistered) || '';

        // Determine highligh
        const isScrap = truthy(r.isScrap);
        const noMovementRecent = (!ds) || (ds !== rel.today && ds !== rel.yesterday && ds !== rel.anteayer);

        if (isScrap) tr.classList.add('row-scrap');
        else if (noMovementRecent) tr.classList.add('row-no-mov');

        // build comment
        let comment = '';
        if (isScrap) comment += 'SCRAP ';
        if (!ds) comment += 'SIN FECHA ';
        else {
          if (ds === rel.yesterday) comment += 'Mov ayer ';
          if (ds === rel.anteayer) comment += 'Mov anteayer ';
          if (ds === rel.today) comment += 'Mov hoy ';
          if (noMovementRecent && !isScrap) comment += 'No mov. recent ';
        }

        // show styled tags
        const isScrapTag = isScrap ? `<span class="tag danger">SCRAP</span>` : `<span class="tag" style="opacity:0.7">${escapeHtml(String(r.isScrap||''))}</span>`;
        const notPackedTag = truthy(r.notPacked) ? `<span class="tag warn">NotPacked</span>` : `<span class="tag" style="opacity:0.7">${escapeHtml(String(r.notPacked||''))}</span>`;

        tr.innerHTML = `<td><strong>${escapeHtml(r.serial||'')}</strong></td>
                        <td>${escapeHtml(r.area||'')}</td>
                        <td>${escapeHtml(r.line||'')}</td>
                        <td>${escapeHtml(r.station||'')}</td>
                        <td>${escapeHtml(r.status||'')}</td>
                        <td>${notPackedTag}</td>
                        <td>${isScrapTag}</td>
                        <td>${escapeHtml(ds)}</td>
                        <td>${escapeHtml(comment)}</td>`;
        resultsTbody.appendChild(tr);
      });
    }

    function escapeHtml(s){
      return String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
    }

    analyzeBtn.addEventListener('click', ()=> {
      const txt = pasteArea.value.trim();
      if (!txt){
        alert('Pega la tabla en el cuadro o sube un archivo Excel primero.');
        return;
      }
      processClipboard(txt);
    });

    clearBtn.addEventListener('click', ()=> {
      pasteArea.value = '';
      parsedRows = [];
      summaryEl.innerHTML = '';
      resultsTbody.innerHTML = '';
      areaFilter.innerHTML = '<option value="">Todas las Áreas</option>';
      lineFilter.innerHTML = '<option value="">Todas las Líneas</option>';
      stationFilter.innerHTML = '<option value="">Todas las Stations</option>';
      statusFilter.innerHTML = '<option value="">Todos los Status</option>';
      fileInput.value = '';
    });

    sampleBtn.addEventListener('click', ()=> {
      const sample = `Serial,Creation Date,Created By,NotPacked,IsScrap,Área,Línea,Station,Status,Date registered
S-1001,2025-09-20,Juan,false,false,Manufactura,Linea A,ST-1,OK,2025-09-22
S-1002,2025-09-20,Maria,true,false,Manufactura,Linea A,ST-2,Pending,2025-09-21
S-1003,2025-09-19,Pedro,false,true,Ensamble,Linea B,ST-4,SCRAP,2025-09-18
S-1004,2025-09-18,Ana,false,false,Ensamble,Linea B,ST-4,OK,
S-1005,2025-09-16,Rosa,false,false,Manufactura,Linea A,ST-1,OK,2025-09-20`;
      pasteArea.value = sample;
    });

    helpBtn.addEventListener('click', ()=> {
      alert('Para pegar desde Excel: selecciona el rango en Excel -> Ctrl+C -> haz click en el cuadro aquí -> Ctrl+V -> luego "Analizar datos". También puedes subir el archivo .xlsx/.csv.');
    });

    [areaFilter, lineFilter, stationFilter, statusFilter].forEach(s => s.addEventListener('change', ()=> {
      renderTable(parsedRows, getRelativeDates());
    }));

    // Copy visible table as CSV to clipboard
    exportCSV.addEventListener('click', async ()=>{
      const rows = Array.from(resultsTbody.querySelectorAll('tr'));
      if (!rows.length){ alert('No hay datos para copiar'); return; }
      const csv = [['Serial','Área','Línea','Station','Status','NotPacked','IsScrap','Date registered','Comentario']];
      rows.forEach(tr => {
        const tds = Array.from(tr.querySelectorAll('td')).map(td=>td.textContent.trim());
        csv.push(tds);
      });
      const csvText = csv.map(r => r.map(cell => `"${cell.replace(/"/g,'""')}"`).join(',')).join('\n');
      try {
        await navigator.clipboard.writeText(csvText);
        alert('Tabla copiada al portapapeles (CSV).');
      } catch(e){
        prompt('Copia el CSV manualmente:', csvText);
      }
    });

    // Small no-auto-analyze paste handler (user decides when to analyze)
    pasteArea.addEventListener('paste', (ev) => {
      // We keep analyze manual to avoid accidental runs while editing
      setTimeout(()=> {
        // nothing automatic
      },50);
    });

    // expose helper for console debugging (optional)
    window.__debug = { parsedRows, runAnalysis, renderTable };
  })();
  </script>
</body>
</html>