<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Centro de Control de Producción v2.0</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    
    <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-firestore-compat.js"></script>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Tinos&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #0F172A; --surface-color: #1E293B; --border-color: #334155;
            --primary-color: #38BDF8; --danger-color: #FB7185; --warning-color: #FBBF24;
            --success-color: #34D399; --text-primary: #F8FAFC; --text-secondary: #94A3B8;
            --text-dark: #64748B;
        }
        body {
            font-family: 'Inter', sans-serif; background-color: var(--bg-color);
            color: var(--text-primary); margin: 0; padding: 16px;
            display: flex; justify-content: center;
        }
        .app-header {
            text-align: center;
            margin-bottom: 16px;
        }
        .app-branding {
            font-family: 'Tinos', 'Times New Roman', serif;
            font-weight: 400;
            font-size: 2.2rem;
            color: var(--text-primary);
            letter-spacing: 2px;
            margin: 0;
        }
        .app-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--text-secondary);
            margin: 4px 0 0 0;
        }
        .main-container {
            width: 100%; max-width: 1600px; display: grid;
            grid-template-columns: 260px 1fr;
            grid-template-rows: auto auto 1fr;
            grid-template-areas: "sidebar global-header" "sidebar header" "sidebar main"; 
            gap: 16px;
        }
        .sidebar {
            grid-area: sidebar; background-color: var(--surface-color); border-radius: 12px;
            padding: 20px; display: flex; flex-direction: column; gap: 16px;
        }
        .global-header { grid-area: global-header; }
        .header { grid-area: header; }
        .main-content { grid-area: main; display: flex; flex-direction: column; gap: 16px; }
        .card {
            background-color: var(--surface-color); border-radius: 12px;
            padding: 20px; border: 1px solid var(--border-color);
        }
        h2, h3 {
            margin-top: 0; margin-bottom: 12px; color: var(--text-secondary);
            font-weight: 600; font-size: 1rem;
        }
        h3 { font-size: 0.9rem; border-bottom: 1px solid var(--border-color); padding-bottom: 8px;}
        .file-drop-area {
            border: 2px dashed var(--border-color); border-radius: 8px; padding: 24px 20px;
            text-align: center; cursor: pointer; transition: all 0.2s ease;
        }
        .file-drop-area.dragover { background-color: #334155; border-color: var(--primary-color); }
        .file-drop-area p { margin: 0; color: var(--text-dark); }
        .file-drop-area span { color: var(--primary-color); font-weight: 500; }
        .order-item { display: flex; align-items: center; gap: 8px; margin-bottom: 8px; }
        .order-item .order-btn { flex-grow: 1; text-align: left; padding: 10px; border-radius: 6px; border: 1px solid var(--border-color); background-color: #334155; color: var(--text-secondary); cursor: pointer; transition: all 0.2s; }
        .order-item .order-btn:hover { background-color: #475569; color: var(--text-primary); }
        .order-item .order-btn.active { background-color: var(--primary-color); color: var(--bg-color); font-weight: 700; border-color: var(--primary-color); }
        .order-item .order-btn.is-complete { background-color: var(--success-color); color: var(--bg-color); border-color: var(--success-color); font-weight: 700;}
        .order-item .order-btn.is-complete:hover { background-color: #4ade80;}
        .order-item .order-btn.is-complete.active { box-shadow: 0 0 0 3px rgba(52, 211, 153, 0.4); }
        .order-item .icon-btn {
            background: none; border: none; color: var(--text-dark); cursor: pointer; padding: 4px;
            display: flex; align-items: center; justify-content: center; transition: all 0.2s;
            font-size: 1.2rem; filter: grayscale(1) opacity(0.6);
        }
        .order-item .icon-btn:hover { color: var(--text-primary); filter: grayscale(0) opacity(1); }
        
        .mode-switcher {
            display: grid; grid-template-columns: 1fr 1fr; gap: 10px; padding: 4px;
            background-color: var(--bg-color); border-radius: 8px; margin-bottom: 16px;
        }
        .mode-switcher button {
            padding: 8px; border: none; background-color: transparent; color: var(--text-secondary);
            font-weight: 600; border-radius: 6px; cursor: pointer; transition: all 0.2s;
        }
        .mode-switcher button.active { background-color: var(--surface-color); color: var(--primary-color); }
        
        .summary-card, .global-dashboard-card {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 16px; text-align: center;
        }
        .stat-item { display: flex; flex-direction: column; justify-content: center; }
        .stat-item h3 { margin: 0 0 8px 0; font-size: 0.9rem; font-weight: 500; }
        .stat-item p { margin: 0; font-size: 1.75rem; font-weight: 700; }
        #statOrderNumber, #statCatalogNumber { color: var(--primary-color); }
        #statCatalogNumber { font-size: 1rem; color: var(--text-primary); font-weight: 500; margin-top: 4px; height: 1.2em; }
        #statPackedQty { color: var(--success-color); }
        #statRemainingQty { color: var(--warning-color); } #statScrapQty { color: var(--danger-color); }

        .table-wrapper { overflow: auto; flex-grow: 1; }
        table { width: 100%; border-collapse: collapse; }
        th, td { padding: 10px 14px; text-align: left; border-bottom: 1px solid var(--border-color); white-space: nowrap; font-size: 0.9rem;}
        thead { position: sticky; top: 0; background-color: var(--surface-color); z-index: 10; }
        th { font-weight: 600; color: var(--text-secondary); font-size: 0.75rem; }
        
        .actions-container { display: flex; flex-direction: column; gap: 10px; }
        .filter-container { display: flex; flex-direction: column; gap: 16px; }
        .filter-group { display: flex; flex-wrap: wrap; gap: 10px; }
        .btn, .filter-btn {
            padding: 8px 14px; border-radius: 6px; cursor: pointer; background-color: #334155;
            border: 1px solid #475569; color: var(--text-secondary); font-weight: 500;
            text-align: center; transition: all 0.2s; font-size: 0.9rem;
        }
        .btn:hover, .filter-btn:hover { background-color: #475569; color: var(--text-primary); }
        .filter-btn.active { color: var(--bg-color); font-weight: 700; background-color: var(--primary-color); border-color: var(--primary-color); }
        .btn { width: 100%; padding: 10px; background-color: var(--primary-color); color: var(--bg-color); font-weight: 700;}
        .btn:disabled { background-color: #334155; color: var(--text-dark); cursor: not-allowed; border-color: #475569;}
        .btn:hover:not(:disabled) { background-color: #67CFFB;}
        #lineCountsContainer { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 16px; }
        .line-badge { background-color: #334155; padding: 4px 12px; border-radius: 16px; font-size: 0.8rem; font-weight: 500; color: var(--text-dark); }
        .line-badge span { font-weight: 700; color: var(--text-secondary); }

        .box-row { cursor: pointer; }
        .box-row:hover { background-color: #334155; }
        .box-row td:first-child::before {
            content: '►'; display: inline-block; margin-right: 10px;
            font-size: 0.7rem; transition: transform 0.2s;
        }
        .box-row.expanded td:first-child::before { transform: rotate(90deg); }
        
        /* === INICIO: SOLUCIÓN CSS PARA TABLA DE EMPAQUE === */
        .serial-row {
            display: none;
        }
        .box-row.expanded + .serial-row {
            display: table-row;
        }
        .serial-row td { background-color: var(--bg-color); padding: 12px 20px 12px 40px; border-color: #2a3a5e; }
        /* === FIN: SOLUCIÓN CSS PARA TABLA DE EMPAQUE === */

        tbody tr.is-scrap { background-color: rgba(251, 113, 133, 0.1) !important; }
        tbody tr.is-scrap td { color: var(--danger-color) !important; }
        tbody tr.is-delayed { background-color: rgba(251, 191, 36, 0.1) !important; }
        tbody tr.is-delayed td { color: var(--warning-color) !important; }
        tbody tr.is-today { background-color: rgba(52, 211, 153, 0.1) !important; }
        tbody tr.is-today td { color: var(--success-color) !important; }
        
        .serial-details-container {
            display: flex;
            flex-direction: column;
            gap: 12px;
            width: 100%;
        }
        .serial-detail-item {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
        }
        .serial-detail-item:last-child {
            border-bottom: none;
            padding-bottom: 0;
        }
        .serial-info, .packing-info {
            display: flex;
            flex-direction: column;
        }
        .packing-info {
            text-align: left;
        }
        .detail-label {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-bottom: 2px;
        }
        .detail-value {
            font-weight: 600;
            font-size: 0.95rem;
        }

        @media (min-width: 500px) {
            .packing-info { text-align: right; }
        }

        #loader, #placeholderText { text-align: center; padding: 60px; color: var(--text-dark); font-size: 1.1rem; }
        
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.6); backdrop-filter: blur(5px);
            display: flex; align-items: center; justify-content: center; z-index: 1000;
            opacity: 0; visibility: hidden; transition: all 0.3s;
        }
        .modal-overlay.visible { opacity: 1; visibility: visible; }
        .modal-content {
            background-color: var(--surface-color); border-radius: 12px; padding: 24px;
            border: 1px solid var(--border-color); width: 90%; max-width: 600px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3); transform: scale(0.95); transition: transform 0.3s;
        }
        .modal-overlay.visible .modal-content { transform: scale(1); }
        .modal-title { font-size: 1.25rem; font-weight: 600; margin: 0; }
        .modal-close { font-size: 1.75rem; color: var(--text-dark); cursor: pointer; line-height: 1; position: absolute; top: 16px; right: 16px; }
        #modalBody textarea, #modalBody pre { 
            width: 100%; min-height: 150px; resize: none; background-color: var(--bg-color); 
            color: var(--text-primary); border: 1px solid var(--border-color); 
            border-radius: 6px; padding: 12px; font-family: 'Inter', sans-serif;
            white-space: pre-wrap; word-wrap: break-word; font-size: 0.9rem;
        }

        body.mode-rastreo #empaqueView { display: none !important; }
        body.mode-empaque #rastreoView { display: none !important; }
        
        .date-group { margin-bottom: 8px; }
        .date-header {
            width: 100%; background-color: var(--bg-color); border: 1px solid var(--border-color);
            border-radius: 6px; padding: 10px 12px; font-weight: 600;
            color: var(--text-secondary); cursor: pointer; display: flex;
            justify-content: space-between; align-items: center; text-align: left;
        }
        .date-header:hover { background-color: #334155; }
        .date-header .status-indicator { font-weight: 400; font-size: 0.8rem; color: var(--success-color); }
        .date-header .collapse-icon { transition: transform 0.2s; }
        .date-group.expanded .date-header .collapse-icon { transform: rotate(90deg); }
        .orders-for-date {
            max-height: 0; overflow: hidden; transition: max-height 0.3s ease-out;
            padding-left: 12px; border-left: 2px solid var(--border-color);
            margin-top: 0;
        }
        .date-group.expanded .orders-for-date {
            max-height: 1000px;
            margin-top: 8px;
        }

        @media (max-width: 992px) {
            body { padding: 8px; }
            .main-container {
                display: flex; flex-direction: column; gap: 12px;
            }
            .sidebar, .main-content, #rastreoView { display: contents !important; }
            .sidebar > h2 { display: none; }
            
            .global-header { order: 1; }
            .header { order: 2; }
            #uploadCard { order: 3; }
            #orderListCard { order: 4; }
            #filtersCard { order: 5; }
            #actionsCard { order: 6; }
            #tableCard { order: 7; }
            #empaqueView { order: 7; }
            
            .global-dashboard-card { grid-template-columns: 1fr 1fr; }
            .summary-card { 
                grid-template-columns: 1fr 1fr; 
                & > .stat-item:has(#statOrderNumber) { grid-column: 1 / -1; }
            }
            .stat-item p { font-size: 1.5rem; }
            
            .card.mobile-collapsible .card-content { display: none; padding-top: 16px; }
            .card.mobile-collapsible.expanded .card-content { display: block; }
            .card.mobile-collapsible h3.mobile-trigger {
                margin-bottom: 0; cursor: pointer; user-select: none;
                display: flex; justify-content: space-between; align-items: center;
            }
            .card.mobile-collapsible h3.mobile-trigger::after {
                content: '►'; display: inline-block; font-size: 0.7rem;
                transition: transform 0.2s; color: var(--text-secondary);
            }
            .card.mobile-collapsible.expanded h3.mobile-trigger::after { transform: rotate(90deg); }
            
            #rastreoTable thead, #empaqueTable thead { display: none; }
            
            #rastreoTable tr { 
                display: block; margin-bottom: 1rem; border-radius: 8px; 
                border: 1px solid var(--border-color); padding: 1rem; 
            }
            #rastreoTable td { 
                display: flex; justify-content: space-between; text-align: right; 
                border: none; padding: 0.5rem 0; white-space: normal;
                border-bottom: 1px solid #0f172a80;
            }
            #rastreoTable tr td:last-child { border-bottom: none; }
            #rastreoTable td::before { 
                content: attr(data-label); float: left; font-weight: bold; 
                text-align: left; margin-right: 1rem; color: var(--text-secondary);
            }

            #empaqueTable, #empaqueTable tbody, #empaqueTable tr { display: block; }
            #empaqueTable .box-row, #empaqueTable .serial-row {
                margin-bottom: 1rem;
                border: 1px solid var(--border-color);
                border-radius: 8px;
            }

            /* === INICIO: SOLUCIÓN CSS MÓVIL PARA TABLA DE EMPAQUE === */
            .box-row.expanded + .serial-row {
                display: block;
            }
            /* === FIN: SOLUCIÓN CSS MÓVIL PARA TABLA DE EMPAQUE === */

            #empaqueTable .box-row { margin-bottom: 0; border-radius: 8px 8px 0 0; }
            #empaqueTable .box-row.expanded { border-bottom-color: transparent; }
             #empaqueTable .serial-row { margin-top: -1px; margin-bottom: 1rem; border-radius: 0 0 8px 8px; }

            #empaqueTable td { display: block; padding: 0.5rem 0; border: none; }
            #empaqueTable .box-row td { 
                display: flex; justify-content: space-between; text-align: right; 
                padding: 0.5rem 0; white-space: normal;
                border-bottom: 1px solid #0f172a80;
            }
            #empaqueTable .box-row { padding: 1rem; }
            #empaqueTable tr td:last-child { border-bottom: none; }
            #empaqueTable .box-row td::before {
                content: attr(data-label); float: left; font-weight: bold; 
                text-align: left; margin-right: 1rem; color: var(--text-secondary);
            }
             #empaqueTable .serial-row td { padding: 1rem; }
        }
    </style>
</head>
<body class="mode-rastreo">
    <div style="width: 100%; max-width: 1800px;">
        <header class="app-header">
            <h1 class="app-branding">CORNING</h1>
            <h2 class="app-title">Centro de Rastreo de Órdenes</h2>
        </header>
        <div class="main-container">
            <aside class="sidebar">
                <h2>Panel de Control</h2>
                <div class="card" id="uploadCard">
                    <h3>Panel de Control</h3>
                    <div class="card-content">
                        <div id="fileDropArea" class="file-drop-area">
                            <p>Arrastra archivos (.xlsx) para cargar/actualizar</p>
                            <p><span>o haz clic para seleccionar</span></p>
                        </div>
                        <input type="file" id="fileInput" accept=".xlsx, .xls" multiple style="display: none;">
                        <input type="file" id="updateFileInput" accept=".xlsx, .xls" style="display: none;">
                    </div>
                </div>
                <div class="card" style="flex-grow: 1;" id="orderListCard">
                    <h3>Órdenes Cargadas</h3>
                    <div class="card-content">
                        <div id="orderList">
                            <p class="text-dark" style="font-size:0.9rem;">Cargando órdenes desde la base de datos...</p>
                        </div>
                    </div>
                </div>
            </aside>
    
            <header class="global-header card">
                <div class="global-dashboard-card">
                       <div class="stat-item"><h3>Órdenes del Día</h3><p id="totalOrdersStat">0</p></div>
                       <div class="stat-item"><h3>Órdenes Terminadas</h3><p id="completedOrdersStat">0</p></div>
                </div>
            </header>
    
            <section class="header card">
                 <div class="mode-switcher">
                    <button id="modeRastreo" class="active">Rastreo</button>
                    <button id="modeEmpaque">Empaque</button>
                </div>
                <div id="summaryCard" class="summary-card">
                       <div class="stat-item">
                            <h3>Orden</h3>
                            <p id="statOrderNumber">N/A</p>
                            <p id="statCatalogNumber"></p>
                       </div>
                       <div class="stat-item"><h3>Cant. Orden</h3><p id="statOrderQty">0</p></div>
                       <div class="stat-item"><h3>Cant. Empacada</h3><p id="statPackedQty">0</p></div>
                       <div class="stat-item"><h3>Restante</h3><p id="statRemainingQty">0</p></div>
                       <div class="stat-item"><h3>Cant. en Scrap</h3><p id="statScrapQty">0</p></div>
                </div>
            </section>
    
            <main class="main-content">
                <div id="rastreoView">
                    <div class="card" id="filtersCard">
                        <h3>Filtros</h3>
                        <div class="card-content">
                            <div class="filter-container">
                                <div>
                                    <h3>Filtrar por Estado</h3>
                                    <div id="rastreoStatusFilters" class="filter-group">
                                        <button class="filter-btn active" data-filter="all">Todos</button>
                                        <button class="filter-btn" data-filter="today">En Movimiento</button>
                                        <button class="filter-btn" data-filter="delayed">Sin Movimiento</button>
                                        <button class="filter-btn" data-filter="scrap">Scrap</button>
                                    </div>
                                </div>
                                <div>
                                    <h3>Filtrar por Línea</h3>
                                    <div id="rastreoLineFilters" class="filter-group">
                                        <p id="rastreoLineFiltersPlaceholder" class="text-dark" style="font-size: 0.9rem;">Cargue un archivo para ver los filtros.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="card" id="actionsCard">
                        <h3>Acciones</h3>
                        <div class="card-content">
                             <div class="actions-container">
                                 <button id="exportViewButton" class="btn" disabled>Exportar Vista a Excel</button>
                                 <button id="exportStatusButton" class="btn" disabled>Generar Reporte de Estatus</button>
                             </div>
                        </div>
                    </div>
                    <div class="card" id="tableCard">
                        <input type="text" id="rastreoFilterInput" placeholder="Buscar en la tabla por serial, status, etc..." style="margin-bottom: 16px;">
                        <div id="lineCountsContainer"></div>
                        <div class="table-wrapper">
                             <table id="rastreoTable"></table>
                             <p id="placeholderText">Cargando datos...</p>
                        </div>
                    </div>
                </div>
                <div id="empaqueView">
                    <div class="card" style="height:100%;">
                        <input type="text" id="empaqueFilterInput" placeholder="Buscar por Serial o BoxID..." style="margin-bottom:16px">
                        <div class="table-wrapper">
                             <table id="empaqueTable"></table>
                        </div>
                    </div>
                </div>
            </main>
        </div>
    </div>
    
    <div id="modalOverlay" class="modal-overlay">
        <div id="modalContent" class="modal-content">
             <span id="modalClose" class="modal-close">&times;</span>
             <h2 id="modalTitle" class="modal-title"></h2>
             <div id="modalBody" style="margin-top:16px; color: var(--text-secondary);"></div>
             <button id="copyReportBtn" class="btn" style="margin-top: 20px; display:none;">Copiar al Portapapeles</button>
        </div>
    </div>

    <script>
        const firebaseConfig = {
            apiKey: "AIzaSyDtlj3ppT9WBGMR60SZx0TZmAo3BXQWDX0",
            authDomain: "rastreador-de-ordenes.firebaseapp.com",
            projectId: "rastreador-de-ordenes",
            storageBucket: "rastreador-de-ordenes.appspot.com",
            messagingSenderId: "956052823395",
            appId: "1:956052823395:web:2ba74d9591d2b24c3cc756"
        };
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();

        document.addEventListener('DOMContentLoaded', () => {
            let loadedOrders = new Map();
            let activeOrderKey = 'all';
            let currentMode = 'rastreo';
            let currentVisibleData = []; 
            let orderToUpdateKey = null;
            
            let rastreoStatusFilter = 'all';
            let rastreoLineFilter = 'all';

            const TRACKING_KEYS = { SERIAL: 'Product Serial Number', IS_SCRAP: 'Is Scrap', NOT_PACKED: 'Not Packed', CREATED_BY: 'Created By', DATE_REGISTERED: 'Date Registered', LINE: 'Line', STATION: 'Station' };
            const PACKING_KEYS = { SERIAL: 'Serial Number', EMPLOYEE_ID: 'Employee ID', PACKED_DATE: 'Finish Packed Date', BOX_ID: 'BoxID' };
            
            const fileDropArea = document.getElementById('fileDropArea');
            const fileInput = document.getElementById('fileInput');
            const updateFileInput = document.getElementById('updateFileInput');
            const orderList = document.getElementById('orderList');
            const statOrderNumber = document.getElementById('statOrderNumber');
            const statCatalogNumber = document.getElementById('statCatalogNumber');
            const statOrderQty = document.getElementById('statOrderQty');
            const statPackedQty = document.getElementById('statPackedQty');
            const statRemainingQty = document.getElementById('statRemainingQty');
            const statScrapQty = document.getElementById('statScrapQty');
            const totalOrdersStat = document.getElementById('totalOrdersStat');
            const completedOrdersStat = document.getElementById('completedOrdersStat');
            const modeRastreo = document.getElementById('modeRastreo');
            const modeEmpaque = document.getElementById('modeEmpaque');
            const rastreoFilterInput = document.getElementById('rastreoFilterInput');
            const rastreoStatusFilters = document.getElementById('rastreoStatusFilters');
            const rastreoLineFilters = document.getElementById('rastreoLineFilters');
            const rastreoLineFiltersPlaceholder = document.getElementById('rastreoLineFiltersPlaceholder');
            const exportViewButton = document.getElementById('exportViewButton');
            const exportStatusButton = document.getElementById('exportStatusButton');
            const lineCountsContainer = document.getElementById('lineCountsContainer');
            const placeholderText = document.getElementById('placeholderText');
            const empaqueFilterInput = document.getElementById('empaqueFilterInput');
            const modalOverlay = document.getElementById('modalOverlay');
            const modalTitle = document.getElementById('modalTitle');
            const modalBody = document.getElementById('modalBody');
            const modalClose = document.getElementById('modalClose');
            const copyReportBtn = document.getElementById('copyReportBtn');

            fileDropArea.addEventListener('click', () => fileInput.click());
            fileDropArea.addEventListener('dragover', (e) => { e.preventDefault(); fileDropArea.classList.add('dragover'); });
            fileDropArea.addEventListener('dragleave', () => fileDropArea.classList.remove('dragover'));
            fileDropArea.addEventListener('drop', (e) => {
                e.preventDefault(); fileDropArea.classList.remove('dragover');
                if (e.dataTransfer.files.length) handleFiles(e.dataTransfer.files);
            });
            fileInput.addEventListener('change', (e) => { if (e.target.files.length) handleFiles(e.target.files); });
            updateFileInput.addEventListener('change', (e) => { if (e.target.files.length) handleFiles(e.target.files, true); });
            
            modeRastreo.addEventListener('click', () => switchMode('rastreo'));
            modeEmpaque.addEventListener('click', () => switchMode('empaque'));

            rastreoFilterInput.addEventListener('input', () => renderRastreoView(activeOrderKey));
            rastreoStatusFilters.addEventListener('click', (e) => {
                if (e.target.matches('.filter-btn')) {
                    rastreoStatusFilters.querySelector('.active').classList.remove('active');
                    e.target.classList.add('active');
                    rastreoStatusFilter = e.target.dataset.filter;
                    renderRastreoView(activeOrderKey);
                }
            });
             rastreoLineFilters.addEventListener('click', (e) => {
                if (e.target.matches('.filter-btn')) {
                    if (rastreoLineFilters.querySelector('.active')) {
                        rastreoLineFilters.querySelector('.active').classList.remove('active');
                    }
                    e.target.classList.add('active');
                    rastreoLineFilter = e.target.dataset.filter;
                    renderRastreoView(activeOrderKey);
                }
            });

            empaqueFilterInput.addEventListener('input', () => renderEmpaqueView(activeOrderKey));
            
            // === INICIO: LÓGICA PARA BOTONES DE EXPORTACIÓN Y REPORTE ===
            exportViewButton.addEventListener('click', handleExportView);
            exportStatusButton.addEventListener('click', handleStatusReport);
            // === FIN: LÓGICA PARA BOTONES DE EXPORTACIÓN Y REPORTE ===

            modalClose.addEventListener('click', hideModal);
            modalOverlay.addEventListener('click', (e) => { if(e.target === modalOverlay) hideModal(); });
            
            function showModal(title, content, type = 'info', showCopyBtn = false) {
                 modalOverlay.querySelector('.modal-content').className = `modal-content ${type}`;
                 modalTitle.textContent = title;
                 modalBody.innerHTML = content; // Can be HTML
                 copyReportBtn.style.display = showCopyBtn ? 'block' : 'none';
                 if (showCopyBtn) {
                    copyReportBtn.onclick = () => {
                        const reportText = modalBody.querySelector('pre, textarea')?.textContent || modalBody.textContent;
                        navigator.clipboard.writeText(reportText).then(() => {
                           showModal('Copiado', 'El reporte se ha copiado al portapapeles.', 'success');
                        }, () => {
                           showModal('Error', 'No se pudo copiar el reporte.', 'error');
                        });
                    };
                 }
                 modalOverlay.classList.add('visible');
            }
            function hideModal() { modalOverlay.classList.remove('visible'); }

            function excelSerialToDate(serial) {
                if (typeof serial !== 'number' || isNaN(serial)) return null;
                try {
                    const decoded = XLSX.SSF.parse_date_code(serial);
                    if (decoded) return new Date(Date.UTC(decoded.y, decoded.m - 1, decoded.d, decoded.H, decoded.M, decoded.S));
                } catch(e) { console.error("Error al parsear la fecha serial de Excel:", e); }
                return null;
            }

            function formatDate(date) {
                if (!(date instanceof Date) || isNaN(date)) return '';
                return date.toLocaleDateString('es-ES', { timeZone: 'UTC', day: '2-digit', month: '2-digit', year: 'numeric' });
            }
            function formatDateTime(date) {
                if (!(date instanceof Date) || isNaN(date)) return '';
                 const day = String(date.getUTCDate()).padStart(2, '0');
                const month = String(date.getUTCMonth() + 1).padStart(2, '0');
                const year = date.getUTCFullYear();
                const hours = String(date.getUTCHours()).padStart(2, '0');
                const minutes = String(date.getUTCMinutes()).padStart(2, '0');
                return `${day}/${month}/${year} ${hours}:${minutes}`;
            }
            function findHeader(headers, keyText) { return headers && headers.find(h => h && h.toLowerCase() === keyText.toLowerCase()); }
            
            async function loadOrdersFromFirebase() {
                try {
                    const snapshot = await db.collection('production_orders').get();
                    const ordersFromDB = new Map();
                    snapshot.forEach(doc => {
                        const data = doc.data();
                        if (data.orderDate && data.orderDate.toDate) { data.orderDate = data.orderDate.toDate(); }
                        const empaqueDataMap = new Map();
                        if (data.empaqueData && Array.isArray(data.empaqueData)) {
                            data.empaqueData.forEach(item => { empaqueDataMap.set(item.boxId, item.serials); });
                        }
                        data.empaqueData = empaqueDataMap;
                        ordersFromDB.set(doc.id, data);
                    });
                    loadedOrders = ordersFromDB;
                    updateOrderList();
                    render();
                } catch (e) {
                    console.error("Error al cargar datos desde Firebase: ", e);
                    showModal('Error de Conexión', 'No se pudieron cargar los datos desde la base de datos.', 'error');
                }
            }
            
            async function saveOrderToFirebase(orderKey, orderData) {
                try {
                    const empaqueDataForDB = Array.from(orderData.empaqueData.entries()).map(([boxId, serials]) => ({ boxId, serials }));
                    const dataToSave = { ...orderData, empaqueData: empaqueDataForDB, lastUpdated: new Date() };
                    await db.collection('production_orders').doc(orderKey).set(dataToSave, { merge: true });
                } catch (e) {
                    console.error("Error al guardar en Firebase: ", e);
                    showModal('Error al Guardar', `No se pudo guardar la orden ${orderKey}.`, 'error');
                }
            }

            async function deleteOrderFromFirebase(orderKey) {
                try {
                    await db.collection('production_orders').doc(orderKey).delete();
                } catch (e) {
                     console.error("Error al eliminar en Firebase: ", e);
                    showModal('Error al Eliminar', `No se pudo eliminar la orden ${orderKey}.`, 'error');
                }
            }

            function handleFiles(files, isUpdate = false) {
                const excelFiles = Array.from(files).filter(f => f.name.endsWith('.xlsx') || f.name.endsWith('.xls'));
                const filePromises = excelFiles.map(file => processFile(file, isUpdate));

                Promise.all(filePromises)
                    .then(results => {
                        let lastKey = activeOrderKey;
                        const updatePromises = [];
                        results.forEach(result => {
                            if (result) {
                                loadedOrders.set(result.key, result.data);
                                updatePromises.push(saveOrderToFirebase(result.key, result.data));
                                lastKey = result.key;
                            }
                        });
                        
                        Promise.all(updatePromises).then(() => {
                            showModal('Éxito', `${results.length} orden(es) cargada(s) y guardada(s).`, 'success');
                            updateOrderList();
                            setActiveOrder(isUpdate ? orderToUpdateKey : lastKey);
                        });
                    })
                    .catch(err => {
                        showModal('Error al Cargar', 'Uno o más archivos no pudieron ser procesados.', 'error');
                        console.error("Error detallado en handleFiles:", err);
                    });
            }

            function processFile(file, isUpdate) {
                 return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const workbook = XLSX.read(new Uint8Array(e.target.result), { type: 'array' });
                            const worksheet = workbook.Sheets[workbook.SheetNames[0]];
                            const orderNumber = String(worksheet['B3']?.v || `Archivo_${file.name.slice(0,10)}`);
                            const keyToUse = isUpdate ? orderToUpdateKey : orderNumber;
                            const TRACKING_COLS = ['B', 'C', 'G', 'K', 'M', 'P', 'V', 'Y', 'Z', 'AA', 'AB'];
                            const PACKING_COLS = { SERIAL: 'AE', EMPLOYEE_ID: 'AF', PACKED_DATE: 'AK', BOX_ID: 'AO' };
                            const rastreoRawData = extractTableData(worksheet, TRACKING_COLS, 20);
                            const packingRawData = extractTableData(worksheet, Object.values(PACKING_COLS), 20, true);
                            const orderData = {
                                orderQty: parseInt(worksheet['O3']?.v || 0),
                                packedQty: parseInt(worksheet['U3']?.v || 0),
                                catalogNumber: worksheet['I3']?.v || 'N/A',
                                orderDate: excelSerialToDate(worksheet['E6']?.v) || new Date(),
                                rastreoData: processRastreoData(rastreoRawData),
                                empaqueData: groupEmpaqueData(packingRawData),
                                headers: {
                                    rastreo: Object.keys(rastreoRawData[0] || {}),
                                    empaque: Object.keys(packingRawData[0] || {})
                                }
                            };
                            resolve({ key: keyToUse, data: orderData });
                        } catch(err) { reject(err); }
                    };
                    reader.readAsArrayBuffer(file);
                });
            }

            function extractTableData(worksheet, targetCols, startRow, isPacking = false) {
                 const headers = {};
                 const colsToUse = isPacking ? Object.keys(PACKING_KEYS) : targetCols;
                 colsToUse.forEach(key => {
                     const col = isPacking ? PACKING_KEYS[key] : key;
                     const cell = worksheet[col + startRow];
                     if(cell && cell.v) headers[col] = cell.v.toString().trim();
                 });
                 if (Object.keys(headers).length === 0) return [];
                 const jsonData = [];
                 const range = XLSX.utils.decode_range(worksheet['!ref']);
                 for (let rowNum = startRow; rowNum <= range.e.r; ++rowNum) {
                     const row = {};
                     let hasData = false;
                     colsToUse.forEach(key => {
                         const col = isPacking ? PACKING_KEYS[key] : key;
                         const headerName = headers[col];
                         if (headerName) {
                             const cellAddress = col + (rowNum + 1);
                             const cell = worksheet[cellAddress];
                             if(cell && cell.v !== undefined) {
                                 row[headerName] = cell.v;
                                 hasData = true;
                             } else {
                                 row[headerName] = '';
                             }
                         }
                     });
                     if (hasData) jsonData.push(row);
                 }
                 return jsonData;
            }
            
            function processRastreoData(data) {
                if (!data || data.length === 0) return [];
                const reynosaTodayString = new Date().toLocaleDateString('en-CA', {
                    timeZone: 'America/Matamoros'
                });
                const headers = Object.keys(data[0] || {});
                const scrapHeader = findHeader(headers, TRACKING_KEYS.IS_SCRAP);
                const dateHeader = findHeader(headers, TRACKING_KEYS.DATE_REGISTERED);

                return data.map(row => {
                    let status = 'normal';
                    const isScrap = String(row[scrapHeader]).trim().toUpperCase() === 'X';

                    if (isScrap) {
                        status = 'scrap';
                    } else {
                        const dateSerial = row[dateHeader];
                        if (dateSerial) {
                            const decodedDate = XLSX.SSF.parse_date_code(dateSerial);
                            if (decodedDate) {
                                const serialDateString = `${decodedDate.y}-${String(decodedDate.m).padStart(2, '0')}-${String(decodedDate.d).padStart(2, '0')}`;
                                if (serialDateString === reynosaTodayString) {
                                    status = 'today';
                                } else if (serialDateString < reynosaTodayString) {
                                    status = 'delayed';
                                }
                            }
                        }
                    }
                    return { ...row, status };
                });
            }

            function groupEmpaqueData(data) {
                if (!data || data.length === 0) return new Map();
                const headers = Object.keys(data[0]);
                const boxIdHeader = findHeader(headers, PACKING_KEYS.BOX_ID);
                return data.reduce((acc, row) => {
                    const boxId = row[boxIdHeader];
                    if (boxId) {
                        if (!acc.has(boxId)) acc.set(boxId, []);
                        acc.get(boxId).push(row);
                    }
                    return acc;
                }, new Map());
            }
            
            function switchMode(mode) {
                currentMode = mode;
                document.body.classList.toggle('mode-rastreo', mode === 'rastreo');
                document.body.classList.toggle('mode-empaque', mode === 'empaque');
                modeRastreo.classList.toggle('active', mode === 'rastreo');
                modeEmpaque.classList.toggle('active', mode === 'empaque');
                render();
            }

            function updateOrderList() {
                orderList.innerHTML = '';
                if (loadedOrders.size === 0) {
                    orderList.innerHTML = '<p class="text-dark" style="font-size:0.9rem;">No hay órdenes cargadas.</p>';
                    return;
                }
                const groupedByDate = new Map();
                for (const [key, order] of loadedOrders.entries()) {
                    const date = order.orderDate || new Date();
                    const dateString = formatDate(date);
                    if (!groupedByDate.has(dateString)) groupedByDate.set(dateString, []);
                    groupedByDate.get(dateString).push({ key, ...order });
                }
                const sortedDates = Array.from(groupedByDate.keys()).sort((a, b) => {
                    const dateA = new Date(a.split('/').reverse().join('-'));
                    const dateB = new Date(b.split('/').reverse().join('-'));
                    return dateB - dateA;
                });
                const todayString = formatDate(new Date());
                sortedDates.forEach(dateString => {
                    const orders = groupedByDate.get(dateString);
                    const isToday = dateString === todayString;
                    const groupDiv = document.createElement('div');
                    groupDiv.className = 'date-group';
                    if (isToday) groupDiv.classList.add('expanded');
                    const headerBtn = document.createElement('button');
                    headerBtn.className = 'date-header';
                    headerBtn.innerHTML = `<span>📅 ${dateString}</span> ${isToday ? '<span class="status-indicator">(Órdenes del Día)</span>' : ''} <span class="collapse-icon">►</span>`;
                    const ordersContainer = document.createElement('div');
                    ordersContainer.className = 'orders-for-date';
                    orders.forEach(order => ordersContainer.appendChild(createOrderButton(order.key, order.key)));
                    groupDiv.appendChild(headerBtn);
                    groupDiv.appendChild(ordersContainer);
                    orderList.appendChild(groupDiv);
                    headerBtn.addEventListener('click', () => groupDiv.classList.toggle('expanded'));
                });
                setActiveOrder(activeOrderKey);
            }

            function createOrderButton(key, text) {
                const item = document.createElement('div'); item.className = 'order-item';
                const btn = document.createElement('button');
                btn.className = 'order-btn'; btn.textContent = text; btn.dataset.key = key;
                btn.onclick = () => setActiveOrder(key);
                const orderData = loadedOrders.get(key);
                if (orderData && orderData.orderQty > 0 && orderData.orderQty <= orderData.packedQty) {
                    btn.classList.add('is-complete');
                }
                item.appendChild(btn);
                if (key !== 'all') {
                    const updateBtn = document.createElement('button');
                    updateBtn.className = 'icon-btn'; updateBtn.title = 'Actualizar orden';
                    updateBtn.innerHTML = `✏️`;
                    updateBtn.onclick = () => { orderToUpdateKey = key; updateFileInput.value = ''; updateFileInput.click(); };
                    item.appendChild(updateBtn);
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'icon-btn'; deleteBtn.title = 'Eliminar orden';
                    deleteBtn.innerHTML = `🗑️`;
                    deleteBtn.onclick = async () => {
                        if (confirm(`¿Estás seguro de que quieres eliminar la orden ${key}?`)) {
                            await deleteOrderFromFirebase(key);
                            loadedOrders.delete(key);
                            if (activeOrderKey === key) activeOrderKey = 'all';
                            updateOrderList();
                            render();
                        }
                    };
                    item.appendChild(deleteBtn);
                }
                return item;
            }

            function setActiveOrder(key) {
                activeOrderKey = key;
                document.querySelectorAll('.order-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.key === key);
                });
                render();
            }

            function render() {
                const hasOrders = loadedOrders.size > 0;
                placeholderText.style.display = hasOrders ? 'none' : 'block';
                exportViewButton.disabled = !hasOrders;
                exportStatusButton.disabled = !hasOrders;
                if (!hasOrders) {
                    document.getElementById('rastreoTable').innerHTML = '';
                    document.getElementById('empaqueTable').innerHTML = '';
                }
                renderSummary();
                updateGlobalDashboard();
                if (currentMode === 'rastreo') {
                    renderRastreoView(activeOrderKey);
                } else {
                    renderEmpaqueView(activeOrderKey);
                }
            }

            function renderSummary() {
                let orderQty = 0, packedQty = 0, scrapCount = 0; let ordersToProcess = [];
                if (activeOrderKey === 'all') {
                    ordersToProcess = Array.from(loadedOrders.values());
                    statOrderNumber.textContent = loadedOrders.size > 0 ? 'Múltiples' : 'N/A';
                    statCatalogNumber.textContent = loadedOrders.size > 0 ? '...' : '';
                } else if (loadedOrders.has(activeOrderKey)) {
                    ordersToProcess = [loadedOrders.get(activeOrderKey)];
                    statOrderNumber.textContent = activeOrderKey;
                    statCatalogNumber.textContent = ordersToProcess[0].catalogNumber;
                } else if (loadedOrders.size > 0) {
                    activeOrderKey = 'all';
                    ordersToProcess = Array.from(loadedOrders.values());
                    statOrderNumber.textContent = 'Múltiples';
                    statCatalogNumber.textContent = '...';
                    setActiveOrder('all');
                }
                ordersToProcess.forEach(order => {
                    orderQty += order.orderQty || 0;
                    packedQty += order.packedQty || 0;
                    if(order.rastreoData) {
                       scrapCount += order.rastreoData.filter(row => row.status === 'scrap').length;
                    }
                });
                statOrderQty.textContent = orderQty;
                statPackedQty.textContent = packedQty;
                statRemainingQty.textContent = orderQty - packedQty;
                statScrapQty.textContent = scrapCount;
            }

            function updateGlobalDashboard() {
                const todayString = formatDate(new Date());
                let todaysOrdersCount = 0; let completedOrdersToday = 0;
                for (const order of loadedOrders.values()) {
                    const orderDateString = formatDate(order.orderDate || new Date());
                    if (orderDateString === todayString) {
                        todaysOrdersCount++;
                        if (order.orderQty > 0 && order.orderQty <= order.packedQty) completedOrdersToday++;
                    }
                }
                totalOrdersStat.textContent = todaysOrdersCount;
                completedOrdersStat.textContent = completedOrdersToday;
            }
            
            function renderRastreoView(key) {
                let dataToShow = []; let headers = [];
                if (key === 'all') {
                    loadedOrders.forEach(order => { if(order.rastreoData) dataToShow.push(...order.rastreoData) });
                    if (loadedOrders.size > 0) headers = Array.from(loadedOrders.values()).find(o => o.headers.rastreo)?.headers.rastreo;
                } else if (loadedOrders.has(key)) {
                    const order = loadedOrders.get(key);
                    dataToShow = order.rastreoData || []; headers = order.headers.rastreo || [];
                }
                createRastreoLineFilters(dataToShow, headers);
                let filteredData = dataToShow;
                if (rastreoStatusFilter !== 'all') filteredData = filteredData.filter(row => row.status === rastreoStatusFilter);
                const lineHeader = findHeader(headers, TRACKING_KEYS.LINE);
                if (rastreoLineFilter !== 'all' && lineHeader) filteredData = filteredData.filter(row => row[lineHeader] === rastreoLineFilter);
                const searchText = rastreoFilterInput.value.toLowerCase();
                if (searchText) filteredData = filteredData.filter(row => Object.values(row).some(val => String(val).toLowerCase().includes(searchText)));
                currentVisibleData = filteredData;
                updateRastreoTable(filteredData, headers);
                updateLineCounts(filteredData, headers);
            }

            function createRastreoLineFilters(data, headers) {
                if (!headers) headers = [];
                const lineHeader = findHeader(headers, TRACKING_KEYS.LINE);
                if (!lineHeader || !data || data.length === 0) {
                    rastreoLineFiltersPlaceholder.textContent = "No hay datos para filtrar.";
                    rastreoLineFiltersPlaceholder.style.display = 'block';
                    rastreoLineFilters.innerHTML = ''; return;
                }
                const uniqueLines = [...new Set(data.map(row => row[lineHeader]).filter(Boolean))].sort();
                rastreoLineFilters.innerHTML = '';
                rastreoLineFiltersPlaceholder.style.display = 'none';
                const allBtn = document.createElement('button');
                allBtn.className = 'filter-btn'; allBtn.textContent = 'Todas';
                allBtn.dataset.filter = 'all'; rastreoLineFilters.appendChild(allBtn);
                uniqueLines.forEach(line => {
                    const lineBtn = document.createElement('button');
                    lineBtn.className = 'filter-btn'; lineBtn.textContent = line;
                    lineBtn.dataset.filter = line; rastreoLineFilters.appendChild(lineBtn);
                });
                const activeBtn = rastreoLineFilters.querySelector(`[data-filter="${rastreoLineFilter}"]`) || rastreoLineFilters.querySelector('[data-filter="all"]');
                if(activeBtn) activeBtn.classList.add('active');
            }
            
            function updateRastreoTable(data, headers) {
                const table = document.getElementById('rastreoTable');
                if (!table) return;
                const isMobile = window.innerWidth <= 992;
                let headersToRender;

                if (isMobile) {
                    headersToRender = [
                        findHeader(headers, TRACKING_KEYS.SERIAL), findHeader(headers, TRACKING_KEYS.LINE),
                        findHeader(headers, TRACKING_KEYS.STATION), findHeader(headers, TRACKING_KEYS.DATE_REGISTERED)
                    ].filter(Boolean);
                } else {
                    const headersToHide = [TRACKING_KEYS.CREATED_BY, TRACKING_KEYS.NOT_PACKED, TRACKING_KEYS.IS_SCRAP].map(h => findHeader(headers, h)).filter(Boolean);
                    headersToRender = headers ? headers.filter(h => !headersToHide.includes(h) && h !== 'status') : [];
                }

                if (!data || data.length === 0 || !headersToRender || headersToRender.length === 0) {
                    table.innerHTML = `<thead><tr><th>No se encontraron resultados.</th></tr></thead>`; return;
                }
                table.innerHTML = `
                    <thead><tr>${headersToRender.map(h => `<th>${h}</th>`).join('')}</tr></thead>
                    <tbody>
                        ${data.map(row => `
                            <tr class="is-${row.status}">
                                ${headersToRender.map(h => `<td data-label="${h}">${formatCell(row[h], h, h === findHeader(headers, TRACKING_KEYS.DATE_REGISTERED))}</td>`).join('')}
                            </tr>
                        `).join('')}
                    </tbody>`;
            }

            function updateLineCounts(data, headers) {
                if (!headers) headers = [];
                const lineHeader = findHeader(headers, TRACKING_KEYS.LINE);
                if (!lineHeader) { lineCountsContainer.innerHTML = ''; return; }
                const counts = data.reduce((acc, row) => {
                    const line = row[lineHeader];
                    if (line) acc[line] = (acc[line] || 0) + 1;
                    return acc;
                }, {});
                
                lineCountsContainer.innerHTML = Object.entries(counts).sort().map(([line, count]) =>
                    `<div class="line-badge">${line}: <span>${count}</span></div>`
                ).join('');
            }
            
            function renderEmpaqueView(key) {
                let dataToShow = new Map(); let headers = [];
                if (key === 'all') {
                    loadedOrders.forEach(order => {
                        if(order.empaqueData) order.empaqueData.forEach((serials, boxId) => {
                            if (!dataToShow.has(boxId)) dataToShow.set(boxId, []);
                            if(serials && serials.length > 0) dataToShow.get(boxId).push(...serials);
                        });
                    });
                    if (loadedOrders.size > 0) {
                        const orderWithHeaders = Array.from(loadedOrders.values()).find(o => o.headers && o.headers.empaque && o.headers.empaque.length > 0);
                        if (orderWithHeaders) headers = orderWithHeaders.headers.empaque;
                    }
                } else if (loadedOrders.has(key)) {
                    const order = loadedOrders.get(key);
                    dataToShow = order.empaqueData || new Map(); headers = order.headers.empaque || [];
                }
                
                const table = document.getElementById('empaqueTable');
                if (!dataToShow || dataToShow.size === 0 || !headers || headers.length === 0) {
                    table.innerHTML = `<thead><tr><th>No hay datos de empaque disponibles.</th></tr></thead>`;
                    return;
                }

                const boxIdHeader = findHeader(headers, PACKING_KEYS.BOX_ID);
                const serialHeader = findHeader(headers, PACKING_KEYS.SERIAL);
                const packedDateHeader = findHeader(headers, PACKING_KEYS.PACKED_DATE);
                const employeeIdHeader = findHeader(headers, PACKING_KEYS.EMPLOYEE_ID);

                if (!boxIdHeader || !serialHeader || !packedDateHeader || !employeeIdHeader) {
                    table.innerHTML = `<thead><tr><th style="color: var(--warning-color);">Error: Columnas de empaque no encontradas en el archivo. Verifique que existan 'BoxID', 'Serial Number', 'Finish Packed Date' y 'Employee ID'.</th></tr></thead>`;
                    return;
                }

                const filterText = empaqueFilterInput.value.toLowerCase();
                let tableHTML = `<thead><tr><th>${boxIdHeader}</th><th>Cantidad</th><th>Último Empaque</th></tr></thead><tbody>`;
                
                for (const [boxId, serials] of dataToShow.entries()) {
                    if(!serials || serials.length === 0) continue;
                    const latestDate = Math.max(...serials.map(s => s[packedDateHeader] || 0));
                    const serialsMatchFilter = serials.some(s => String(s[serialHeader]).toLowerCase().includes(filterText));
                    if (!String(boxId).toLowerCase().includes(filterText) && !serialsMatchFilter) continue;
                    
                    let serialsDetailsHTML = '<div class="serial-details-container">';
                    serials.forEach(serial => {
                        serialsDetailsHTML += `
                            <div class="serial-detail-item">
                                <div class="serial-info">
                                    <span class="detail-label">Serial:</span>
                                    <span class="detail-value">${serial[serialHeader]}</span>
                                </div>
                                <div class="packing-info">
                                    <span class="detail-label">Empacador:</span>
                                    <span class="detail-value">${serial[employeeIdHeader] || 'N/A'}</span>
                                    <span class="detail-label" style="margin-top: 5px;">Fecha:</span>
                                    <span class="detail-value">${formatDateTime(excelSerialToDate(serial[packedDateHeader]))}</span>
                                </div>
                            </div>`;
                    });
                    serialsDetailsHTML += '</div>';

                    tableHTML += `
                        <tr class="box-row" data-boxid="${boxId}">
                            <td data-label="Box ID">${boxId}</td>
                            <td data-label="Cantidad">${serials.length}</td>
                            <td data-label="Último Empaque">${formatDateTime(excelSerialToDate(latestDate))}</td>
                        </tr>
                        <tr class="serial-row" data-parentbox="${boxId}">
                            <td colspan="3">${serialsDetailsHTML}</td>
                        </tr>`;
                }
                tableHTML += `</tbody>`;
                table.innerHTML = tableHTML;

                table.querySelectorAll('.box-row').forEach(row => {
                    row.addEventListener('click', () => row.classList.toggle('expanded'));
                });
            }

            // === INICIO: FUNCIONES DE ACCIONES (EXPORTAR Y REPORTE) ===
            function handleExportView() {
                if (currentVisibleData.length === 0) {
                    showModal('Exportar Vista', 'No hay datos en la vista actual para exportar.', 'warning');
                    return;
                }
                try {
                    const worksheet = XLSX.utils.json_to_sheet(currentVisibleData);
                    const workbook = XLSX.utils.book_new();
                    XLSX.utils.book_append_sheet(workbook, worksheet, 'Vista Actual');
                    const orderName = (activeOrderKey && activeOrderKey !== 'all') ? activeOrderKey : 'Multiples_Ordenes';
                    XLSX.writeFile(workbook, `Reporte_Vista_${orderName}.xlsx`);
                } catch(e) {
                    console.error("Error al exportar a Excel:", e);
                    showModal('Error', 'Ocurrió un error al generar el archivo de Excel.', 'error');
                }
            }
            
            function handleStatusReport() {
                if (activeOrderKey === 'all' || !loadedOrders.has(activeOrderKey)) {
                    showModal('Generar Reporte', 'Por favor, seleccione una sola orden para generar el reporte de estatus.', 'warning');
                    return;
                }
                const order = loadedOrders.get(activeOrderKey);
                const data = order.rastreoData || [];
                const total = data.length;
                const today = data.filter(r => r.status === 'today').length;
                const delayed = data.filter(r => r.status === 'delayed').length;
                const scrap = data.filter(r => r.status === 'scrap').length;
                const normal = data.filter(r => r.status === 'normal').length;
                
                let report = `REPORTE DE ESTATUS - ORDEN: ${activeOrderKey}\n`;
                report += `CATÁLOGO: ${order.catalogNumber || 'N/A'}\n`;
                report += `--------------------------------------------------\n`;
                report += `TOTAL DE PIEZAS REGISTRADAS: ${total}\n`;
                report += `  - En Movimiento (Hoy):     ${today}\n`;
                report += `  - Sin Movimiento (Retraso): ${delayed}\n`;
                report += `  - En Scrap:                 ${scrap}\n`;
                report += `  - Sin Estatus (Normal):     ${normal}\n`;
                report += `--------------------------------------------------\n`;
                
                if (delayed > 0) {
                    report += `\nDESGLOSE DE PIEZAS SIN MOVIMIENTO:\n`;
                    const lineHeader = findHeader(order.headers.rastreo, TRACKING_KEYS.LINE);
                    const stationHeader = findHeader(order.headers.rastreo, TRACKING_KEYS.STATION);
                    
                    const delayedByLine = data.filter(r => r.status === 'delayed').reduce((acc, row) => {
                        const line = row[lineHeader] || 'Sin Línea';
                        if (!acc[line]) acc[line] = 0;
                        acc[line]++;
                        return acc;
                    }, {});

                    for (const [line, count] of Object.entries(delayedByLine)) {
                        report += `  - ${line}: ${count} pz\n`;
                    }
                }
                showModal(`Reporte de Estatus: ${activeOrderKey}`, `<pre>${report}</pre>`, 'info', true);
            }
            // === FIN: FUNCIONES DE ACCIONES (EXPORTAR Y REPORTE) ===

            function formatCell(value, header, isDateTime = false) {
                 if (isDateTime) return formatDateTime(excelSerialToDate(value));
                 if (header && header.toLowerCase().includes('date')) return formatDate(excelSerialToDate(value));
                 return value === undefined || value === null ? '' : value;
            }
            
            let isMobile = window.innerWidth <= 992;
            const cardIds = ['uploadCard', 'orderListCard', 'filtersCard', 'actionsCard'];
            function setupMobileMode() {
                cardIds.forEach(id => {
                    const cardElement = document.getElementById(id);
                    if (!cardElement) return;
                    cardElement.classList.add('mobile-collapsible');
                    const trigger = cardElement.querySelector('h3');
                    if (trigger) {
                        trigger.classList.add('mobile-trigger');
                        if (!trigger.dataset.mobileListener) {
                            trigger.addEventListener('click', () => {
                                if(window.innerWidth <= 992) cardElement.classList.toggle('expanded');
                            });
                            trigger.dataset.mobileListener = 'true';
                        }
                    }
                });
            }
            function teardownMobileMode() {
                 cardIds.forEach(id => {
                    const cardElement = document.getElementById(id);
                    if (!cardElement) return;
                    cardElement.classList.remove('mobile-collapsible', 'expanded');
                    const trigger = cardElement.querySelector('h3');
                    if(trigger) trigger.classList.remove('mobile-trigger');
                 });
            }
            window.addEventListener('resize', () => {
                const newIsMobile = window.innerWidth <= 992;
                if (newIsMobile !== isMobile) {
                    isMobile = newIsMobile;
                    if (isMobile) setupMobileMode(); else teardownMobileMode();
                    render();
                }
            });
            loadOrdersFromFirebase();
            if (isMobile) setupMobileMode();
        });
    </script>
</body>
</html>